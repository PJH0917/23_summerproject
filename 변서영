#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#define N 41
int see();
int memorize();



int main(void){
   int a = 0;

   printf("***프로그램 용어 단어장***\n\n");
   printf("보기용을 보시려면 '1', 암기용를 보시려면 '2'를 눌러주세요.\n");
   scanf(" %d", &a);
   
   if (a == 1) {
      see();
   }
   else if (a == 2) {
      memorize();
   }
   else {
      while(1) {
         printf("'1'또는 '2' 둘 중에 하나를 골라주십시오.\n");
         scanf(" %d", &a);
         if (a == 1) {
            see();
            break;
         }
         else if (a == 2) {
            memorize();
            break;
         }
       } 
   }
   return 0;
}


#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#define N 41//용어 갯수

int see();
int memorize();
int list();


int main(void){
	int a = 0;

	printf("***프로그램 용어 단어장***\n\n");
	printf("보기용을 보시려면 '1', 암기용를 보시려면 '2'를 눌러주세요.\n");//보기용 1, 암기용 2 입력
	scanf(" %d", &a);
	
	if (a == 1) {
		see();
	}
	else if (a == 2) {
		memorize();
	}
	else {//정해진 선택지 이외의 답을 고를 경우, 경고문나오며 올바른 입력을 할 때까지 다시 선택하게 함
		while(1) {
			printf("'1'또는 '2' 둘 중에 하나를 골라주십시오.\n");
			scanf(" %d", &a);
			if (a == 1) {
				see();
				break;
			}
			else if (a == 2) {
				memorize();
				break;
			}
	    } 
	}
	return 0;
}



int see() {//보기용 단어장 함수
	printf("여기서부터는 '보기용' 단어장입니다.\n");	
	list(1);
}


int memorize() {//암기용 단어장 함수
	int b = 0;
	printf("여기서부터는 '암기용' 단어장입니다.\n");
	printf("용어 가림막으로 볼려면 '1', 설명 가림막으로 볼려면 '2'를 눌러주세요.\n");
	scanf("%d", &b);
	

	if (b == 1) {//용어 가림막	
		list(21);
	}
	else if (b == 2) {//설명 가림막
		list(22);
	}
	else {//정해진 선택지 이외의 답을 고를 경우, 경고문나오며 올바른 입력을 할 때까지 다시 선택하게 함
		while (1) {
			printf("'1'또는 '2' 둘 중에 하나를 골라주십시오.\n");
			scanf(" %d", &b);
			memorize();
		}
	}
}

int list(int n) {
	//용어 정리함
	char list1[N][20] = { "전처리", "컴파일","링크" "함수","printf ","Stdio.h", " 제어문자","상수","변수","int",
	"double","char","Scanf","산술연산자","대입연산자","증감연산자","관계연산자","논리연산자","sizeof연산자","조건연산자",
	"if문","if~else문", "If~else if~else문","Switch~case문","while문", "for문","do~while문","함수 선언","함수 정의","함수 호출",
	"배열","gets", "puts",  "포인터","strcpy","strlen","strcat", "strcmp","지역변수","전역변수",
	"정적지역변수" };//41개

	char list2[N][100] = { "NULL","NULL","NULL","NULL",  "printf(“  ”);" , "Include <stdio.h> ","NULL", "Ex. 태어난 시간(장소), 생물학적 부모님 ",  "Ex. 나이, 키, 몸무게",
	"int age; ","double height; ", "char food; ", "scanf(“%d”, &a); ", "c=a+b;,c=a-b;c=a/b;, c=a*b; c=a%b; ", "=  ",
   "++a;, b++;, --c;, d--; ", "a>b;, a<b;, a>=b;, a<=b;, a==b;, a!=b; ","(a>10)&&(a>7);,(a>10)||(a>7);,!(a>10); ",
	 "sizeof(변수명 또는 자료형) ","(조건) ? (참일 시) : (거짓일 시);", "If(조건식) 실행문; ", "if(조건문) 실행문1; else 실행문2; ",
	" else if (조건문2) 실행문2;else 실행문; ", "switch(조건식){ case상수식1; 실행문; break;case 상수식2; 실행문; break;default; 실행문; break; } ",
	 "while(조건식){ 실행문; } ", "변수형 함수명(변수명,1 변수명2); ", "변수형 함수 이름(변수명1,변수명2){기능; reture 반환값;} ",
	"함수이름(변수명3,변수명4) ; ", "자료형 배열명[N]={값1,값2,값3.....값N}; ","for(초기식; 조건식; 증감식){ 실행문; } ",
   "Do{실행문; }while (조건식); ",  "gets(배열명); ","puts(배열명); ", "변수형 *포인터명=&변수명 ",
	"Strcpy(문자열1,문자열2); ","Strlen(문자열); ", "Strcat(문자열1, 문자열2); ",  "strcmp (문자열1, 문자열2); ",
	 "함수 안에서 변수 선언 ", "함수밖에서 변수 선언 ","static 변수형 변수명;  " };

	char list3[N][250] = {
	 "전처리 지시자에 따라 소스파일을 가공하는 과정"
	,"CPU가 해설할 수 있는 명령어들로 구성된 개체파일로 바꾸는 과정 "
	,"개체파일에 startup code를 결합하는 과정 "
	,"머리(함수 원형)와 몸통으로 구성되어 있다. "
	,"화면에 데이터를 일정한 형식에 따라 출력할 수 있다."
	,"C언어에서 기본으로 사용하는 입출력 함수가 들어가 있다."
	,"NULL"
	,"값이 변하지 않는 데이터 "
	,"값이 바뀌는 데이터 "
	,"변수형 중 하나로 정수를 넣을 수 있다. 관련된 출력 변환 문자: %d "
	,"변수형 중 하나로 실수를 넣을 수 있다. 관련된 출력 변환 문자: %lf "
	,"변수형 중 하나로 실수를 넣을 수 있다. 관련된 출력 변환 문자: %lf "
	,"입력 문자들을 스캔하여 원하는 형태의 데이터를 변수에 삽입할 수 있다. *주의사항: 문자열 변환문자를 제외한 변수명 앞에 &를 붙여야 정상적으로 작동한다. 또한 띄어쓰기를 할 시 뒤 문장은 인식하지 못한다 "
	,"덧셈, 뺄셈, 나눗셈, 곱셈, 나머지를 계산하는 연산자 "
	,"변수에 값을 대입하는 연산자 "
	,"변수의 값을 1씩 증가시키거나 감소시킬 수 있다. 변수명 앞에 있으면 계산 전에, 뒤에 있으면 계산 후에 변수값을 변경시킨다"
	,"“크다, 작다, 크거나 같다, 작거나 같다, 같다, 같지 않다” 와 같이 변수 간의 관계를 계산한다. 컴퓨터는 ‘0’를 거짓, ‘0’를 제외한 모든 수를 참이라고 판단한다.(보통 참의 표시로’1’를 쓰곤 한다) "
	,"집합에서 쓰이는 합집합, 교집합, 여집합를 뜻하며 참과 거짓을 판단하는데 쓰이는 연사자 "
	,"피연산자의 크기를 바이트 단위로 계산해서 알려줄 수 있는 연산자 "
	,"조건이 참이냐 거짓이냐에 따라 다른 명령을 수행하도록 하는 연산자 "
	,"조건식이 참일 시 실행문 실행, 거짓이면 아무것도 실행하지 않음. "
	,"조건식1이 참이면 실행문1만 실행, 조건식2이 참이면 실행문2을 실행함"
	,"조건이 참이냐 거짓이냐에 따라 다른 명령을 수행하도록 하는 연산자 "
	,"조건이 참이냐 거짓이냐에 따라 다른 명령을 수행하도록 하는 연산자 "
	,"조건이 참이냐 거짓이냐에 따라 다른 명령을 수행하도록 하는 연산자 "
	,"형식이 while문과 다르긴 하지만 원리는 똑같다. 정확한 숫자를 반복하기에 유용하다. "
	,"특이하게 실행문을 무조건 실행한 후 조건에 맞으면 반복이 되는 반복문으로 무조건 한 번은 실행되어야 한다면 해당 반복문을 쓰는 게 효율적이다. "
	,"함수의 형태를 알리며, 컴퓨터가 함수의 존재를 인식할 수 있도록 코드 처음에 함수 선언을 써 놓는다.  "
	,"해당 함수의 기능을 구현한다. 보통 메인 코드 앞에 놓아 함수선언을 하는 귀찮음을 없앤다. "
	,"함수를 사용하는 명령어로 함수에 필요한 값을 인수로 준다. "
	,"각 변수가 일련의 연관성이 있을 경우, 효율성을 위해 사용하곤 한다. *주의 사항: 변수의 요소는 0~N-1이다. 2차원,3차원 배열도 있다. "
	,"Scanf과 같이 문자열을 받을 수 있으나 띄어쓰기를 하면 뒤는 나오지 않는 Scanf와 달리 Enter직전까지 모든 문자열이 다 저장된다. 하지만 입력한 배열의 크기를 검사하지 않기 때문에 오류가 생길 수도 있으니 주의해야한다. "
	,"Printf와 같은 기능을 수행하지만 출력 후 수동으로 줄을 바꿔줘야하는 printf와 달리 자동으로 줄을 바꿔준다.  "
	,"NULL"
	,"문자열2를 문자열1에 복사한다. "
	,"문자열의 길이(문자수)를 구해 반환시킨다. "
	,"문자열2에다가 문자열1를 이어붙임 "
	,"문자열1이 문자열2보다 크면 1반환하고 무자열1이 문자열2보다 작으면 -1반환, 둘이 같은 문자열이면 0반환한다. "
	,"지역변수란 일정한 지역에서만 사용할 수 있는 변수를 뜻합니다. 그렀기 때문에 이름이 같아도 선언된 함수가 다르다면 가각 독립된 저장공간을 갖습니다. 메모리를 효율적으로 사용 가능하며 디버깅에 유리하기 때문에 사용합니다. "
	,"코드의 모든 함수 내외에서 사용이 가능합니다. 그렀기 때문에 여러 함수에서 쉽게 공유가능하다는 장점이 있지만 용량을 많이 사용하며 전역변수의 값이 잘못된다면 전역 변수가 사용된 모든 함수를 고쳐야 한다는 단점이 있습니다. "
	,"프로그램이 실행될 동안에 계속 유지되므로써 함수가 끝나면 초기화되는 지역변수와 차이가 있다. "
	};

	if (n == 1) {//보기용 단어장
		int q = 1;
		for (int p = 0; p < N; p++) {
			printf("\n%d.%s", q, list1[p]);
			q++;
			printf("\n:");
			printf("%s\n", list3[p]);
			printf("형식: %s\n", list2[p]);
		}
	}
	else if (n == 21) {//암기용-용어 가림막 버전
		srand((unsigned int)time(NULL));
		int k1[N] = { NULL };

		int g1 = 0;

		while (g1 != (N - 1))
		{
			int n = 100;
			n = rand() % N;
			//같은 숫자 번복되지 않도록 하는 조건식
			if (k1[0] != n && k1[1] != n && k1[2] != n && k1[3] != n && k1[4] != n && k1[5] != n && k1[6] != n && k1[7] != n && k1[8] != n && k1[9] != n && k1[10] != n
				&& k1[11] != n && k1[12] != n && k1[13] != n && k1[14] != n && k1[15] != n && k1[16] != n && k1[17] != n && k1[18] != n && k1[19] != n && k1[20] != n
				&& k1[21] != n && k1[22] != n && k1[23] != n && k1[24] != n && k1[25] != n && k1[26] != n && k1[27] != n && k1[28] != n && k1[29] != n && k1[30] != n
				&& k1[31] != n && k1[32] != n && k1[33] != n && k1[34] != n && k1[35] != n && k1[36] != n && k1[37] != n && k1[38] != n && k1[39] != n && k1[40] != n
				)
			{
				k1[g1] = n;
				g1++;
			}

		}

		for (int p = 0, q = 1; p < N; p++, q++) {
			printf("\n%d. ??? \n", q);
			printf(":%s\n", list3[k1[p]]);
		}
	}
	else if (n == 22) {//암기용-설명 가림막 버전
		srand((unsigned int)time(NULL));
		int k2[N] = { NULL };
		int g2 = 0;

		while (g2 != (N - 1))
		{
			int n = 100;
			n = rand() % N;
			//같은 숫자 번복되지 않도록 하는 조건식
			if (k2[0] != n && k2[1] != n && k2[2] != n && k2[3] != n && k2[4] != n && k2[5] != n && k2[6] != n && k2[7] != n && k2[8] != n && k2[9] != n && k2[10] != n
				&& k2[11] != n && k2[12] != n && k2[13] != n && k2[14] != n && k2[15] != n && k2[16] != n && k2[17] != n && k2[18] != n && k2[19] != n && k2[20] != n
				&& k2[21] != n && k2[22] != n && k2[23] != n && k2[24] != n && k2[25] != n && k2[26] != n && k2[27] != n && k2[28] != n && k2[29] != n && k2[30] != n
				&& k2[31] != n && k2[32] != n && k2[33] != n && k2[34] != n && k2[35] != n && k2[36] != n && k2[37] != n && k2[38] != n && k2[39] != n && k2[40] != n
				)
			{
				k2[g2] = n;
				g2++;
			}

		}

		for (int p = 0, q = 1; p < N; p++, q++) {
			printf("\n%d.%s\n", q, list1[k2[p]]);
			printf("설명: ???\n");
		}
	}

}
